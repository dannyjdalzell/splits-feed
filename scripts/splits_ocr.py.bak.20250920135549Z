#!/usr/bin/env python3
import argparse, csv, hashlib, os, re, sys, time
from datetime import datetime
from dateutil import tz
from PIL import Image, ImageOps, ImageFilter
import pytesseract
import numpy as np
import cv2

HEADER = [
  "image_filename","image_sha256","image_bytes","image_mtime_utc",
  "source","league","event_date","teams","market","side",
  "handle_pct","bets_pct","odds","total_value","ticket_count",
  "notes"
]

# Infer source by filename prefix
def infer_source(name:str)->str:
    n = name.lower()
    for k in ["vsinlive","betmgm","betmgmnews","actionnetworkhq","covers","pregame","sbr","espn","draftkings","dk"]:
        if n.startswith(k+"_") or n.startswith(k+"-"):
            return k
    if n.startswith("img_") or n.startswith("screenshot"):
        return "camera"
    return "unknown"

def sha256_file(path):
    h = hashlib.sha256()
    with open(path,"rb") as f:
        for chunk in iter(lambda: f.read(1<<20), b""):
            h.update(chunk)
    return h.hexdigest(), os.path.getsize(path)

def load_cv_gray(path):
    # handle webp/jpg/png transparently via PIL -> np
    im = Image.open(path).convert("RGB")
    im = ImageOps.exif_transpose(im)
    arr = np.array(im)
    g = cv2.cvtColor(arr, cv2.COLOR_RGB2GRAY)
    # light denoise and threshold
    g = cv2.medianBlur(g, 3)
    _, th = cv2.threshold(g, 0, 255, cv2.THRESH_BINARY+cv2.THRESH_OTSU)
    return th

PCT = re.compile(r'(?<!\d)(\d{1,3})\s*%')
ODDS = re.compile(r'([+-]\d{2,4})')
TOTAL = re.compile(r'\b(?:[uo]|o/u|total|tot)\s*[:\-]?\s*([0-9]{1,2}(?:\.[05])?)', re.I)

def extract_fields(ocr_text:str):
    t = ocr_text.replace('\n',' ').replace('\r',' ')
    # bets/handle: take the two highest % as candidates, or label pairs seen near keywords
    pcts = [int(x) for x in PCT.findall(t) if 0 <= int(x) <= 100]
    handle = bets = None
    # keyword cue
    if "handle" in t.lower():
        # naive: first pct after 'handle'
        h_idx = t.lower().find("handle")
        after = PCT.findall(t[h_idx:h_idx+40]) if h_idx>-1 else []
        if after: handle = int(after[0])
    if "bets" in t.lower():
        b_idx = t.lower().find("bets")
        after = PCT.findall(t[b_idx:b_idx+40]) if b_idx>-1 else []
        if after: bets = int(after[0])
    # fallback: choose two largest unique pcts
    if handle is None or bets is None:
        uniq = sorted(set(pcts), reverse=True)
        if len(uniq)>=2:
            if handle is None: handle = uniq[0]
            if bets is None: bets = uniq[1] if uniq[1]!=handle else (uniq[2] if len(uniq)>2 else uniq[0])

    odds = None
    m = ODDS.findall(t)
    if m: odds = m[0]

    total_value = None
    mt = TOTAL.search(t)
    if mt: total_value = mt.group(1)

    # Very light team parsing (kept generic)
    # Look for "TEAM @ TEAM" or "TEAM vs TEAM"
    tvs = re.search(r'([A-Z][A-Za-z\.\s]{2,20})\s*(?:@|vs\.?|v)\s*([A-Z][A-Za-z\.\s]{2,20})', t)
    teams = None
    if tvs:
        a = tvs.group(1).strip()
        b = tvs.group(2).strip()
        teams = f"{a} @ {b}"

    return handle, bets, odds, total_value, teams

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--images", required=True)
    ap.add_argument("--out", required=True)
    args = ap.parse_args()

    img_dir = args.images
    out_csv = args.out
    rejects_csv = os.path.splitext(out_csv)[0] + "_rejects.csv"

    # Gather images
    exts = {".png",".jpg",".jpeg",".webp",".jfif",".bmp"}
    images = []
    for root, _, files in os.walk(img_dir):
        for f in files:
            if os.path.splitext(f)[1].lower() in exts:
                images.append(os.path.join(root,f))
    images.sort(key=lambda p: os.path.getmtime(p))

    tz_utc = tz.tzutc()
    ok = 0
    bad = 0

    with open(out_csv,"w",newline="",encoding="utf-8") as fo, \
         open(rejects_csv,"w",newline="",encoding="utf-8") as fr:
        w = csv.DictWriter(fo, fieldnames=HEADER)
        r = csv.DictWriter(fr, fieldnames=HEADER + ["reject_reason"])
        w.writeheader()
        r.writeheader()

        for path in images:
            name = os.path.basename(path)
            source = infer_source(name)
            sha, size = sha256_file(path)
            mtime = datetime.utcfromtimestamp(os.path.getmtime(path)).replace(tzinfo=tz_utc).isoformat()

            try:
                th = load_cv_gray(path)
                # OCR English
                text = pytesseract.image_to_string(th, config="--psm 6")
                handle, bets, odds, total_value, teams = extract_fields(text)

                row = dict.fromkeys(HEADER, "")
                row.update({
                    "image_filename": name,
                    "image_sha256": sha,
                    "image_bytes": size,
                    "image_mtime_utc": mtime,
                    "source": source,
                    "league": "",           # optional enrichment later
                    "event_date": "",       # optional enrichment later
                    "teams": teams or "",
                    "market": "consensus",
                    "side": "",             # fill later if detected
                    "handle_pct": handle if handle is not None else "",
                    "bets_pct": bets if bets is not None else "",
                    "odds": odds or "",
                    "total_value": total_value or "",
                    "ticket_count": "",
                    "notes": ""
                })

                # basic accept rule: at least one of handle/bets/odds present
                has_signal = any([row["handle_pct"]!="", row["bets_pct"]!="", row["odds"]!="", row["total_value"]!=""])
                if has_signal:
                    w.writerow(row); ok += 1
                else:
                    row["reject_reason"] = "no_signal_fields"
                    r.writerow(row); bad += 1

            except Exception as e:
                row = dict.fromkeys(HEADER, "")
                row.update({
                    "image_filename": name,
                    "image_sha256": sha,
                    "image_bytes": size,
                    "image_mtime_utc": mtime,
                    "source": source,
                })
                row["reject_reason"] = f"exception:{type(e).__name__}"
                r.writerow(row); bad += 1

    print(f"Done. Accepted rows: {ok}, Rejected rows: {bad}")
    print(f"Wrote: {out_csv}")
    print(f"Rejects: {rejects_csv}")
if __name__ == "__main__":
    main()
